export {
    createDocument,
    createNamedDocument,
    deleteDocument,
    deleteDocumentField,
    deleteDocuments,
    incrementDocumentField,
    readDocument,
    readDocuments,
    recursivelyUploadDataObject,
    updateChildDocuments,
    updateDocument,
    updateDocumentField,
    uploadCollections,
}
/* deno-fmt-ignore */ import {txv, splitTwice,splitOnceReverse, maybe, getTestData, fooga, denoDebug, denobug, isAbsolutePath, templater3, splitInHalf, pop4, map4, visit, AbstractVisitor, shellEscape, getkv, toggleBooleanState, numbered, noidea, assertObjectValue, assertValue, getClasses, exit, choose, getFileName, testEqual, pause, getBindingValueString, templater2, smartDedent5, pop3, moduleExports, joinPath, expandPath, isDecimal, hasPercentage, ass, parsePercentage, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"

import {
    addDoc,
    arrayRemove,
    arrayUnion,
    collection,
    deleteDoc,
    deleteField,
    doc,
    getDoc,
    getDocs,
    getFirestore,
    increment,
    limit,
    onSnapshot,
    orderBy,
    query,
    serverTimestamp,
    setDoc,
    updateDoc,
    where,
    writeBatch,
} from "firebase/firestore"
import { initializeApp } from "firebase/app"
// import { decypher } from "@bkl/shared/utilities"
// right now ... 'decypher' is just a place holder saying hello

import * as env from "@bkl/env"
const app = initializeApp(env.HAMMY_MATH_CLASS_FIREBASE_CONFIG)
const db = getFirestore()

function getDocData(doc) {
    return doc.exists() ? { id: doc.id, ...doc.data() } : null
}

async function createChildCollection(...args) {
    const [path, payload] = splitOnceReverse(args)
    const docRef = doc(db, ...path)
    return await setDoc(docRef, payload)
}

async function createNamedDocument(...args) {
    const [path, payload] = splitOnceReverse(args)
    const docRef = doc(db, ...path)
    return await setDoc(docRef, payload)
}
async function createDocument(...args) {
    const [path, payload] = splitOnceReverse(args)
    const docRef = doc(db, ...path)
    return await setDoc(docRef, payload)
}

async function updateChildDocuments(...args) {
    const [path, payload] = splitOnceReverse(args)
    for (const { id, arg } of payload) {
        const docRef = doc(db, ...path, id)
        return await updateDoc(docRef, arg)
    }
}

async function updateDocument(...args) {
    const [path, payload] = splitOnceReverse(args)
    const docRef = doc(db, ...path)
    return await updateDoc(docRef, txv(payload, firebaseTransformer))
}

async function readDocument(...path) {
    try {
        const data = await getDoc(doc(db, ...path))
        return getDocData(data)
    } catch(e) {
        return 
    }
}

async function readDocuments(...path) {
    const collectionRef = collection(db, ...path)
    const data = await getDocs(collectionRef)
    return data.docs.map(getDocData)
}

async function deleteDocument(...path) {
    return await deleteDoc(doc(db, ...path))
}

async function deleteDocuments(path, deletionKeys) {
    for (const deletion of deletionKeys) {
        await deleteDocument(path, deletion)
    }
}

async function updateDocumentField(...args) {
    let [path, field, payload] = splitOnceReverse(args, 2)
    switch (type(payload)) {
        case "Object":
            payload = payload
            break
        case "Array":
            payload = arrayUnion(...payload)
            break
    }

    const docRef = doc(db, ...path)
    await updateDoc(docRef, { [field]: payload })
}

async function deleteDocumentField(...args) {
    const [path, field] = splitOnceReverse(args, 1)
    const docRef = doc(db, ...path)
    await updateDoc(docRef, { [field]: deleteField() })
}

async function incrementDocumentField(...args) {
    if (!isNumber(getLast(args))) {
        args.push(1)
    }
    const [path, field, n] = splitOnceReverse(args, 2)
    return await updateDoc(doc(db, ...path), {
        [field]: increment(n),
    })
}

async function recursivelyUploadDataObject(data) {
    if (isArray(data)) {
        for (const arg of data) {
            await uploadData(arg)
        }
    } else {
        await uploadData(data)
    }
    console.log("done!")

    function getPath(data, basePath) {
        return filter([basePath, data.id], exists).join("/")
    }
    async function uploadData(data, basePath, collRef) {
        if (data.type === "collection") {
            for (const item of data.value) {
                const collectionPath = getPath(data, basePath)
                await uploadData(item, collectionPath)
            }
        } else if (data.type === "document" && collRef) {
            // console.log('xxxx')
            // console.log('adding')
            // await addDoc(collRef, data.value)
        } else if (data.type === "document") {
            const documentPath = getPath(data, basePath)
            console.log(documentPath)
            const docRef = doc(db, documentPath)
            let docData = {}
            if (isArray(data.value)) {
                for (const item of data.value) {
                    if (item.type === "attribute") {
                        docData[item.key] = item.value
                    } else if (item.type === "collection") {
                        const collRef = collection(
                            docRef,
                            item.id,
                        )
                        for (const arg of item.value) {
                            await addDoc(collRef, arg.value)
                        }
                    }
                }
            } else {
                docData = data.value
            }
            if (data.id) {
                await mergeDoc(docRef, docData)
            } else {
                await addDoc(docRef, docData)
            }
        }
    }
}
async function mergeDoc(docRef, data) {
    return await setDoc(docRef, data, { merge: true })
}

async function uploadCollections(o, overwrite = true) {
    for (const [k, v] of Object.entries(o)) {
        await uploadObject(k, v)
    }
    return true

    async function uploadObject(collectionId, v) {
        if (isObject(v)) {
            for (const [documentId, data] of Object.entries(v)) {
                if (
                    !overwrite &&
                    await readDocument(collectionId, documentId)
                ) {
                    console.log(
                        `document at ${collectionId}/${documentId} already exists`,
                    )
                    continue
                }
                const ref = doc(db, collectionId, documentId)
                await setDoc(ref, data)
            }
        } else if (isArray(v)) {
            for (const data of v) {
                const ref = doc(db, collectionId)
                await addDoc(ref, data)
            }
        }
    }
}

async function deleteCollectionDocuments(collectionPath) {
    // deletes all documents in a collection
    // but does not delete the collection itself
    const collectionRef = collection(db, collectionPath)
    const querySnapshot = await getDocs(collectionRef)

    for (const docSnapshot of querySnapshot.docs) {
        const docRef = docSnapshot.ref
        await deleteDoc(docRef)
        console.log(`Deleted document: ${docRef.id}`)
    }
}

// deleteCollection('MyDailyTracker')
// updateDocument('users', 'pivnurt', {accountType: 'npc', studentGroup: ['Dr. Harfun', 'Sammy', 'Hammy']})
// updateDocumentField('users', 'pivnurt', 'studentGroup', ['Gogo'])
// incrementDocumentField('users', 'pivnurt', 'age', -1)
// updateDocument('users', 'pivnurt', {username: 'pivnurt'})

// const assignments = await readDocuments('users', 'pivnurt', 'assignments')
// const id = assignments[0].assignmentId
// const assignment = await readDocument('assignments', id)
// console.log(assignment)
//

// await deleteDocument('assignments', '0')
// await deleteDocument('assignments', '1')
// console.log('done')
// recursivelyUploadDataObject(pivnurt)
// updateDocument('users', 'pivnurt', {password: 'icecream'})
// readDocuments('users').then(console.log)
//

function createAssignment(assignmentId) {
    return {
        assignmentId,
        score: 0,
        status: "awaiting",
        startTime: Date.now(),
        endTime: 0,
        attempts: 0,
    }
}
function createAssignmentId(className, number) {
    const n = match(className, /\d+/)
    const topic = match(
        className.toLowerCase(),
        /chemistry|math/,
    )
    const key = `G${n}-${topic}-${number}`
    return key
}
function createNPC(name) {
    const npcGroup = [
        "hammy",
        "sammy",
        "gougou",
        "maomao",
        "pivnurt",
        "jean",
        "harfun",
    ]

    const username = name
    const o = {}
    o.username = username
    o.fullName = name
    o.age = 10
    o.class = "6th Grade Chemistry"
    o.accountType = "NPC"
    o.studentGroup = npcGroup
    o.joinDate = datestamp()
    o.password = "icecream"
    o.region = "Meadowdale"
    const assignments = [1, 2, 3].map((x) =>
        createAssignment(createAssignmentId(o.class, x))
    )
    o.assignments = documentCollection(assignments)
    return {
        data: o,
        path: `users/${username}`,
    }
}

function documentCollection(items) {
    class DocumentCollection {
        constructor(items) {
            this.items = items
        }
    }
    return new DocumentCollection(items)
}

function createStudent(o) {
    o.assignments = documentCollection(createAssignments(o))
    return {}
}

async function uploadPathObject(o) {
    const { path, data } = o

    assert(path)
    assert(data)

    if (isArray(data)) {
        for (const arg of data) {
            await uploadData(arg)
        }
    } else {
        await uploadData(data)
    }

    async function uploadData(data) {
        const docRef = doc(db, path)
        const [nested, regular] = splitTwice(
            data,
            typef("DocumentCollection"),
        )

        await setDoc(docRef, regular, { merge: true })

        // unnamed subcollectionIds
        for (
            const [k, documentCollection] of Object.entries(
                nested,
            )
        ) {
            const collectionRef = collection(docRef, k)
            for (const document of documentCollection.items) {
                await addDoc(collectionRef, document)
            }
        }
    }
}

function firebaseTransformer(v) {
    switch (v) {
        case "serverTimestamp":
        case "TIMESTAMP":
            return serverTimestamp()
        case "increment":
        case "INCREMENT":
            return increment(1)
        case "decrement":
        case "DECREMENT":
            return increment(-1)
        case "delete":
        case "DELETE":
            return deleteField()
    }
    const m = match(String(v), /^[+-]\d+$/)
    if (m) {
        return increment(Number(m))
    }
    return v
}


function useFirebaseAdmin(username) {
}
async function asyncMap(items, fn) {
    const store = []
    for (const item of items) {
        store.push(await fn(item))
    }
    return store
}
function useFirebaseStudent(studentUsername) {
    async function getAssignmentArticles() {
        const assignments = await getAssignments()
        async function get(x) {
            const id = x.assignmentId
            return await readDocument('assignments', id)
        }
        return await asyncMap(assignments, get)
    }

    async function getAssignments() {
        const assignments = await readDocuments('users', studentUsername, 'assignments')
        return assignments
    }

    async function getAccount() {
        const account = await readDocument('users', studentUsername)
        return account
    }

    async function editAssignment(id, payload) {
        const segments = [
            "users",
            studentUsername,
            "assignments",
            id,
        ]
        await updateDocument(...segments, payload)
        return true
    }
    async function editAssignments(callback) {
        const collectionRef = collection(
            db,
            "users",
            studentUsername,
            "assignments",
        )
        const data = await getDocs(collectionRef)
        const assignments = data.docs.map(getDocData)
        for (let i = 0; i < assignments.length; i++) {
            const assignment = assignments[i]
            const value = callback(assignment, i)
            if (value) {
                const docRef = data.docs[i].ref
                await updateDoc(docRef, value)
            }
        }
        return true
    }
    return {
        editAssignment,
        editAssignments,
        getAccount,
        getAssignments,
        getAssignmentArticles,
    }
}

// const { editAssignment, getAssignmentArticles, getAssignments, getAccount } = useFirebaseStudent("jean")

// const account = await getAccount()
// const assignments = await getAssignments()
// const assignmentArticles = await getAssignmentArticles()
// console.log(account)
// console.log(assignments)
// console.log(assignmentArticles)

function callbacker(assignment, i) {
    const assignmentId = createAssignmentId(
        "Grade 6 Chemistry",
        i + 1,
    )
    const startTime = serverTimestamp()
    return {
        startTime,
        assignmentId,
    }
}
// editAssignment("ld4hc1RcOb1Koa9Mrw13", { attempts: "+10", score: "+3", startTime: 'TIMESTAMP' })
    // .then(console.log)
// uploadPathObject(createNPC('jean'))
// console.log(createNPC('jean'))
// const assignmentId = createAssignmentId('Grade 6 Chemistry', 1)
// console.log(assignmentId)
